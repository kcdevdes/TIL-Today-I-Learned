# 스프링 핵심 이해2

## 새로운 할인 정책 도입

할인 정책을 변경할려면 클라이언트 `OrderServiceImpl` 을 변경하여야 한다.

- 역할과 구현 분리 → OK
- 다형성 활용, 인터페이스와 객체 분리 → OK
- OCP, DIP 준수 → NG
- DIP: 의존관계를 분석하면, 추상뿐만 아니라 구현에도 의존 중.
- OCP: 지금 코드는 기능을 확장해서 변경하면 클라이언트 코드에 영향을 줌.

## 해결 방안

- AppConfig는 실제 동작에 필요한 구현 객체를 생성한다.
- AppConfig는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입(연결)해준다.
- 인터페이스, 구현클래스들은 오로지 생성자를 통해 구현체를 주입 받으므로 DIP원칙을 지킬 수 있다.
- 구현체가 필요하다? → appConfig.getMemberService(); appConfig.getOrderService(); 가져오기

## AppConfig 개선 방안

- 메서드 분리 → 각 구현체 리턴 메서드를 분리함으로서 새로운 정책이 실행되더라도 리턴 메서드만 수정하면 문제 없어짐.

## 좋은 객체지향 개발 원칙

1. SRP 단일 책임 원칙
    1. 구현 객체 생성 및 연결하는 책임은 AppConfig가 담당
    2. 클라이언트 객체는 실행하는 책임만 담당
2. DIP 의존 관계 역전 원칙
    1. 추상화에 의존해야지, 구체화에 의존하면 안된다.
    2. AppConfig가 FixedDiscountPolicy 객체 인스턴스를 클라이언트 코드 대신 생성해서 의존관계를 주입했다.
3. OCP
    1. 다형성 사용하고 클라이언트가 DIP를 지킨다.
    2. 애플리케이션을 사용영역과 구성 영역으로 나눈다.
    3. AppConfig가 의존관계를 FixedDiscountPolicy → RateDiscountPollicy로 변경, 클라이언트 코드에 주입.
    4. 확장에 대해서 사용 영역 변경은 닫혀있는 것이 됨 → 철저히 원칙 준수

## IoC, DI, Container

- 제어의 역전
    - 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행. → 프로그램의 제어 흐름을 스스로 조종함.
    - AppConfig가 제어 흐름을 가져감. 구현 객체는 자신의 로직을 실행하는 역할만 담당.
    - 제어 흐름은 모두 AppConfig가 가지고 있고, OrderServiceImpl또한 AppConfig가 생성 및 제어한다.
- 프레임워크 vs 라이브러리
    - 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크 (Spring Boot)
    - 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리

## 의존 관계 주입

- OrderServiceImpl은 DiscountPolicy 인터페이스에 의존. 실제 어떤 구현 객체가 사용될지는 모른다.
- 즉, 의존관계는 정적인 클래스 의존 관계와 실행 시점에서 결정되는 동적인 객체 의존 관계 둘을 분리해서 생각해야만 한다.
- 애플리케이션 런타임에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것 → 의존 관계 주입

## IoC컨테이너, DI 컨테이너

- AppConfig마냥 객체를 생성, 관리하면서 의존 관계 연결해주는 것 → IoC 컨테이너 (DI Container)
- 최근에는 DI Container라고 부른다.

## 스프링 컨테이너

- ApplicationContext: Spring 컨테이너
- AppConfig의 DI대신, 스프링 컨테이너에 등록 후 자동 등록으로 전환
- `@Configuration`이 붙은 클래스를 설정 구성 정보로 활용. `@Bean`이 붙은 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록. 이 객체들을 *스프링 빈*이라고 한다.
- 스프링 빈은 @Bean이 붙은 메서드의 명을 빈의 이름으로 사용한다.
- ctx.getBean()을 통해 빈을 가져올 수 있다.
- 모든 객체는 스프링 빈으로 등록되고, 컨테이너에서 빈을 찾아 사용하도록 한다.